---
title: "HW3_567"
author: "Matthew Stoebe"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
install.packages("Lock5Data")
library(Lock5Data)
data(CommuteAtlanta)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

#a
```{r cars}
# Load the required package and data
library(Lock5Data)
data(CommuteAtlanta)

# Extract the 'Time' variable
times <- CommuteAtlanta$Time

# Plot the histogram
hist(times, breaks = 30, col = "lightblue", main = "Histogram of Commute Times", xlab = "Commute Time (minutes)")



```
#b
```{r pressure, echo=FALSE}
mean_time <- mean(times)
mean_time

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#c
```{r}
# Perform t-test to get the confidence interval
t_test_result <- t.test(times)
t_test_result$conf.int


```

#d
```{r}
# Define the bootstrap function
bootstrap_mean <- function(data, R) {
  set.seed(12345)  # For reproducibility
  n <- length(data)
  boot_means <- numeric(R)
  for (i in 1:R) {
    sample_i <- sample(data, n, replace = TRUE)
    boot_means[i] <- mean(sample_i)
  }
  return(boot_means)
}

# Run the bootstrap
R <- 2000
boot_means <- bootstrap_mean(times, R)

# Histogram of bootstrap means
hist(boot_means, breaks = 30, col = "lightgreen", main = "Histogram of Bootstrap Means", xlab = "Bootstrap Means")

# Q-Q plot of bootstrap means
qqnorm(boot_means, main = "Q-Q Plot of Bootstrap Means")
qqline(boot_means, col = "red")

```
#e

The histogram of means does appear to be bell shaped and symetric. This makes sense as wek know that according to CLT, the sampling distribution of the sample mean will be approximately normal when the sample size is large enough. WIth our sample size of 2000, the CLT should hold. 

#f
```{r}
# Original sample mean
mean_orig <- mean(times)

# Bootstrap mean
mean_bootstrap <- mean(boot_means)

# Bias
bias <- mean_bootstrap - mean_orig

# Variance
variance <- var(boot_means)

# Mean Squared Error
MSE <- variance + bias^2

# Display results
bias
variance
MSE

```
#g
```{r}
# Calculate the percentile confidence interval
alpha <- 0.05
CI_percentile <- quantile(boot_means, probs = c(alpha/2, 1 - alpha/2))
CI_percentile

```
#h
```{r}
# Calculate the basic confidence interval
CI_basic_lower <- 2 * mean_orig - quantile(boot_means, probs = 1 - alpha/2)
CI_basic_upper <- 2 * mean_orig - quantile(boot_means, probs = alpha/2)
CI_basic <- c(CI_basic_lower, CI_basic_upper)
CI_basic

```
#i
```{r}
n <- length(times)
mean_orig <- mean(times)
sd_orig <- sd(times)
SE_orig <- sd_orig / sqrt(n)

set.seed(12345)  # For reproducibility
R <- 2000
t_boot <- numeric(R)

for (i in 1:R) {
  sample_i <- sample(times, n, replace = TRUE)
  mean_i <- mean(sample_i)
  sd_i <- sd(sample_i)
  SE_i <- sd_i / sqrt(n)
  t_boot[i] <- (mean_i - mean_orig) / SE_i
}

alpha <- 0.05
t_lower <- quantile(t_boot, alpha/2)
t_upper <- quantile(t_boot, 1 - alpha/2)

CI_lower <- mean_orig - t_upper * SE_orig
CI_upper <- mean_orig - t_lower * SE_orig
CI_studentized <- c(CI_lower, CI_upper)
CI_studentized


```

